//
// Created by wpsimon09 on 12/10/24.
//

#include "VImage.hpp"

#include <thread>
#include <vulkan/vulkan_enums.hpp>

#include "Application/Logger/Logger.hpp"
#include "Vulkan/Global/GlobalStructs.hpp"
#include "Vulkan/Global/GlobalVariables.hpp"
#include "Vulkan/VulkanCore/Device/VDevice.hpp"
#include "Vulkan/Utils/VGeneralUtils.hpp"
#include "stb_image/stb_image.h"
#include "Vulkan/VulkanCore/Buffer/VBuffer.hpp"
#include "Vulkan/VulkanCore/CommandBuffer/VCommandBuffer.hpp"
#include "Vulkan/Utils/VIimageTransitionCommands.hpp"

VulkanCore::VImage::VImage(const VulkanCore::VDevice &device, vk::Image image, int widht, int height,
                           uint32_t mipLevels, vk::Format format, vk::ImageAspectFlags aspecFlags, std::optional<vk::ImageUsageFlags> usageFlags, vk::SampleCountFlagBits samples):
    m_device(device), m_imageVK(image), m_imageVMA(image), m_mipLevels(mipLevels), m_format(format), m_aspectFlags(aspecFlags), m_width(widht), m_height(height), m_samples(samples)
{
    // creates from exisitng vulkan image
    if (usageFlags.has_value())
    {
        m_imageUsage = usageFlags.value();
    }

    m_path = "Image generated by swap chain";

    m_isSwapChainImage = true;
    m_isDepthBuffer = false;

    GenerateImageView();
}


VulkanCore::VImage::VImage(const VulkanCore::VDevice &device, uint32_t mipLevels,
                           vk::Format format, vk::ImageAspectFlags aspecFlags, std::optional<vk::ImageUsageFlags> imageUsage,vk::SampleCountFlagBits samples):
    m_device(device), m_mipLevels(mipLevels), m_format(format), m_aspectFlags(aspecFlags), m_samples(samples),
    m_imageUsage(imageUsage.value_or(vk::ImageUsageFlagBits::eTransferDst | vk::ImageUsageFlagBits::eSampled | vk::ImageUsageFlagBits::eTransferSrc))
    {

    // creates new vulkan image

    m_isSwapChainImage = false;
    m_transferCommandBuffer = std::make_unique<VCommandBuffer>(m_device,m_device.GetSingleThreadCommandPool());

    // resize is called later so this is correct, i just didn`t want to bloat the constructor arguments
    m_width = m_height = 1;



    if((aspecFlags & vk::ImageAspectFlagBits::eColor) && !(m_imageUsage.value() & vk::ImageUsageFlagBits::eColorAttachment)) {
        AllocateImage(0);
        m_isDepthBuffer = false;
        VulkanStructs::ImageData dummyImageData = {};
        dummyImageData.channels = 4;
        dummyImageData.height = 1;
        dummyImageData.widht = 1;

        uint32_t* dummyPixels =new uint32_t[]{ 0xFFFF69B4, 0xFFFFFFF };
        // dummy data for pink color if proper image is not loaded yet
        dummyImageData.pixels = dummyPixels;
        FillWithImageData<uint32_t>(dummyImageData, true);
        GenerateImageView();
    }
    if ((m_aspectFlags & vk::ImageAspectFlagBits::eColor) && (m_imageUsage.value() & vk::ImageUsageFlagBits::eColorAttachment))
    {
        AllocateImage(0);;
        GenerateImageView();
    }
    if(m_aspectFlags & vk::ImageAspectFlagBits::eDepth) {
        AllocateImage(0);
        m_isDepthBuffer = true;
        GenerateImageView();
    }

}

 VulkanCore::VImage::VImage(const VulkanCore::VDevice& device, VulkanStructs::ImageData<uint32_t>& imageData): m_device(device), m_mipLevels(1), m_format(vk::Format::eR8G8B8A8Unorm), m_aspectFlags(vk::ImageAspectFlagBits::eColor), m_samples(vk::SampleCountFlagBits::e1),
 m_imageUsage(vk::ImageUsageFlagBits::eTransferDst | vk::ImageUsageFlagBits::eSampled | vk::ImageUsageFlagBits::eTransferSrc)
 {
    m_isSwapChainImage = false;
    m_isDepthBuffer = false;
    m_transferCommandBuffer = std::make_unique<VCommandBuffer>(m_device,m_device.GetSingleThreadCommandPool());

    // resize is called later so this is correct, i just didn`t want to bloat the constructor arguments
    m_width = imageData.widht;
    m_height = imageData.height;

    AllocateImage(0);
    FillWithImageData<uint32_t>(imageData, true);
    GenerateImageView();
 }


//--------------------------
// IMAGE LAYOUT TRANSITION
//--------------------------
void VulkanCore::VImage::TransitionImageLayout(vk::ImageLayout currentLayout, vk::ImageLayout targetLayout) {
    Utils::Logger::LogInfoVerboseOnly("Transition image layout...");

    bool flushAfterTransition = false;
    auto imageTransitionedFence = VulkanCore::VSyncPrimitive<vk::Fence>(m_device);

    m_imageLayout = targetLayout;


    vk::ImageMemoryBarrier barrier{};
    barrier.oldLayout = currentLayout;
    barrier.newLayout = targetLayout;
    barrier.srcQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.dstQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.image = m_imageVK;
    barrier.subresourceRange.aspectMask = m_isDepthBuffer ? vk::ImageAspectFlagBits::eDepth : vk::ImageAspectFlagBits::eColor;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = 1;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;

    

    if(! m_transferCommandBuffer->GetIsRecording())
    {
        flushAfterTransition = true;
        m_transferCommandBuffer->BeginRecording();
    }
    RecordImageTransitionLayoutComand(currentLayout, targetLayout, barrier, *m_transferCommandBuffer);
    if (flushAfterTransition)
    {
        m_transferCommandBuffer->EndAndFlush(m_device.GetTransferQueue());
    }

}

void VulkanCore::VImage::TransitionImageLayout(vk::ImageLayout currentLayout, vk::ImageLayout targetLayout, VulkanCore::VCommandBuffer &commandBuffer)
{
    m_imageLayout = targetLayout;

    vk::PipelineStageFlags srcStageFlags;
    vk::PipelineStageFlags dstStageFlags;

    vk::ImageMemoryBarrier barrier{};
    barrier.oldLayout = currentLayout;
    barrier.newLayout = targetLayout;
    barrier.srcQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.dstQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.image = m_imageVK;
    barrier.subresourceRange.aspectMask = m_isDepthBuffer ? vk::ImageAspectFlagBits::eDepth : vk::ImageAspectFlagBits::eColor;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = 1;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;

    RecordImageTransitionLayoutComand(currentLayout, targetLayout, barrier, commandBuffer);
}


void VulkanCore::VImage::TransitionImageLayout(vk::ImageLayout currentLayout, vk::ImageLayout targetLayout,
    std::vector<vk::Semaphore> &waitSemaphores, std::vector<vk::PipelineStageFlags>& waitStages,
    std::vector<vk::Semaphore> &signalSemaphores)
{
    bool flushAfterTransition = false;

    m_imageLayout = targetLayout;

    vk::ImageMemoryBarrier barrier{};
    barrier.oldLayout = currentLayout;
    barrier.newLayout = targetLayout;
    barrier.srcQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.dstQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.image = m_imageVK;
    barrier.subresourceRange.aspectMask = m_isDepthBuffer ? vk::ImageAspectFlagBits::eDepth : vk::ImageAspectFlagBits::eColor;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = 1;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;

    if(! m_transferCommandBuffer->GetIsRecording())
    {
        flushAfterTransition = true;
        m_transferCommandBuffer->BeginRecording();
    }
    RecordImageTransitionLayoutComand(currentLayout, targetLayout, barrier, *m_transferCommandBuffer);

    if (flushAfterTransition)
    {
        m_transferCommandBuffer->EndAndFlush(m_device.GetTransferQueue(), waitSemaphores, waitStages, signalSemaphores);
    }

}

vk::DescriptorImageInfo VulkanCore::VImage::GetDescriptorImageInfo(vk::Sampler &sampler) {
    vk::DescriptorImageInfo imageInfo{};
    imageInfo.imageLayout = m_imageLayout;
    imageInfo.imageView = m_imageView;
    imageInfo.sampler = sampler;
    return imageInfo;
}


//-----------------------------
// STAGING BUFFER -> IMAGE CPY
//-----------------------------
void VulkanCore::VImage::CopyFromBufferToImage() {
    Utils::Logger::LogInfoVerboseOnly("Copying image from buffer to image...");
    vk::BufferImageCopy region = {};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = 1;

    region.imageOffset.x = 0;
    region.imageOffset.y = 0;
    region.imageOffset.z = 0;

    region.imageExtent.width = m_width;
    region.imageExtent.height = m_height;
    region.imageExtent.depth = 1;

    assert(
        m_transferCommandBuffer->GetIsRecording() && "Command buffer that will copy buffer to image is not recording, enable it using BeginRecording method");
    m_transferCommandBuffer->GetCommandBuffer().copyBufferToImage(m_stagingBufferWithPixelData->GetStagingBuffer(),
                                                                  m_imageVK, vk::ImageLayout::eTransferDstOptimal, 1,
                                                                  &region);

}

void VulkanCore::VImage::GenerateImageView() {

    vk::ImageViewCreateInfo createInfo{};
    createInfo.image = m_imageVK;
    createInfo.format = m_format;
    createInfo.viewType = vk::ImageViewType::e2D;
    createInfo.subresourceRange.aspectMask = m_aspectFlags;
    createInfo.subresourceRange.baseMipLevel = 0;
    createInfo.subresourceRange.levelCount = m_mipLevels;
    createInfo.subresourceRange.baseArrayLayer = 0;
    createInfo.subresourceRange.layerCount = 1;

    m_imageView = m_device.GetDevice().createImageView(createInfo);
    assert(m_imageView);
    Utils::Logger::LogInfoVerboseOnly("2D Image view created");

}

void VulkanCore::VImage::AllocateImage(size_t imageSize) {
    //create vulkan represetnation of the image
    VkImageCreateInfo imageInfo = {};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.width = m_width;
    imageInfo.extent.height = m_height;
    imageInfo.extent.depth = 1;
    imageInfo.mipLevels = m_mipLevels;
    imageInfo.arrayLayers = 1;
    imageInfo.format = static_cast<VkFormat>(m_format);
    imageInfo.tiling = static_cast<VkImageTiling>(vk::ImageTiling::eOptimal);
    imageInfo.initialLayout = static_cast<VkImageLayout>(vk::ImageLayout::eUndefined);
    imageInfo.usage = static_cast<VkImageUsageFlags>(m_imageUsage.value());
    imageInfo.sharingMode = static_cast<VkSharingMode>(vk::SharingMode::eExclusive);
    imageInfo.samples = static_cast<VkSampleCountFlagBits>(m_samples);

    //m_imageVK = m_device.GetDevice().createImage(imageInfo);

    // create vma allocation
    VmaAllocationCreateInfo imageAllocationInfo = {};
    imageAllocationInfo.usage = VMA_MEMORY_USAGE_AUTO;
    imageAllocationInfo.flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
    assert(
        vmaCreateImage(m_device.GetAllocator(), &imageInfo, &imageAllocationInfo, &m_imageVMA, &m_imageAllocation,
            nullptr) == VK_SUCCESS);
    vmaSetAllocationName(m_device.GetAllocator(), m_imageAllocation, "<== IMAGE ==>");

    m_imageVK = m_imageVMA;
}


void VulkanCore::VImage::Resize(uint32_t newWidth, uint32_t newHeight) {
    m_width = newWidth;
    m_height = newHeight;
    Utils::Logger::LogInfoVerboseOnly("Resizing the image...");
        Destroy();
        AllocateImage(m_imageSize);
        GenerateImageView();
        Utils::Logger::LogSuccess("Image resized, its data will not be preserved to preserve data call FillImageWithData() !");
}

void VulkanCore::VImage::Destroy() {
    if (!m_isSwapChainImage) {
        vmaDestroyImage(m_device.GetAllocator(), m_imageVMA, m_imageAllocation);

    }
    m_device.GetDevice().destroyImageView(m_imageView);
    Utils::Logger::LogInfoVerboseOnly("Deleted image and its image view");
}
