//
// Created by wpsimon09 on 12/10/24.
//

#include "VImage.hpp"

#include <thread>

#include "Application/Logger/Logger.hpp"
#include "Vulkan/Global/GlobalStructs.hpp"
#include "Vulkan/Global/GlobalVariables.hpp"
#include "Vulkan/VulkanCore/Device/VDevice.hpp"
#include "Vulkan/Utils/VGeneralUtils.hpp"
#include "stb_image/stb_image.h"

VulkanCore::VImage::VImage(const VulkanCore::VDevice &device, vk::Image image, int widht, int height,
                           uint32_t mipLevels, vk::Format format, vk::ImageAspectFlags aspecFlags):
    m_device(device), m_imageVK(image), m_imageVMA(image), m_mipLevels(mipLevels), m_format(format), m_aspectFlags(aspecFlags), m_width(widht), m_height(height) {

    m_path = "Image generated by swap chain";

    m_isSwapChainImage = true;
    m_isDepthBuffer = false;

    GenerateImageView();
}

VulkanCore::VImage::VImage(const VulkanCore::VDevice &device, uint32_t mipLevels,
                           vk::Format format, vk::ImageAspectFlags aspecFlags):
    m_device(device), m_mipLevels(mipLevels), m_format(format), m_aspectFlags(aspecFlags) {

    m_isSwapChainImage = false;
    m_transferCommandBuffer = std::make_unique<VCommandBuffer>(m_device, m_device.GetTransferCommandPool());

    m_width = m_height = 1;

    if(aspecFlags & vk::ImageAspectFlagBits::eColor) {
        AllocateImage(0);
        m_isDepthBuffer = false;
        VulkanStructs::ImageData dummyImageData = {};
        dummyImageData.channels = 4;
        dummyImageData.height = 1;
        dummyImageData.widht = 1;

        uint32_t dummyPixels[] = { 0xFFFF69B4, 0xFFFFFFF };
        // dummy data for pink color if proper image is not loaded yet
        dummyImageData.pixels = dummyPixels;
        FillWithImageData(dummyImageData, true);
        GenerateImageView();
    }
    if(m_aspectFlags & vk::ImageAspectFlagBits::eDepth) {
        AllocateImage(0);
        m_isDepthBuffer = true;
        GenerateImageView();
    }

}



//--------------------------
// IMAGE LAYOUT TRANSITION
//--------------------------
void VulkanCore::VImage::TransitionImageLayout(vk::ImageLayout currentLayout, vk::ImageLayout targetLayout) {
    Utils::Logger::LogInfoVerboseOnly("Transition image layout...");

    m_imageLayout = targetLayout;

    vk::PipelineStageFlags srcStageFlags;
    vk::PipelineStageFlags dstStageFlags;

    vk::ImageMemoryBarrier barrier{};
    barrier.oldLayout = currentLayout;
    barrier.newLayout = targetLayout;
    barrier.srcQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.dstQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.image = m_imageVK;
    barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = 1;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;

    if (currentLayout == vk::ImageLayout::eUndefined && targetLayout == vk::ImageLayout::eTransferDstOptimal) {
        barrier.srcAccessMask = {};
        barrier.dstAccessMask = vk::AccessFlagBits::eTransferWrite;

        srcStageFlags = vk::PipelineStageFlagBits::eTopOfPipe;
        dstStageFlags = vk::PipelineStageFlagBits::eTransfer;
    }
    else if (currentLayout == vk::ImageLayout::eTransferDstOptimal && targetLayout ==
        vk::ImageLayout::eShaderReadOnlyOptimal) {
        barrier.srcAccessMask = vk::AccessFlagBits::eTransferWrite;
        barrier.dstAccessMask = vk::AccessFlagBits::eShaderRead;

        srcStageFlags = vk::PipelineStageFlagBits::eTransfer;
        dstStageFlags = vk::PipelineStageFlagBits::eFragmentShader;
    }
    else if (currentLayout == vk::ImageLayout::eUndefined && targetLayout ==
        vk::ImageLayout::eColorAttachmentOptimal) {
        barrier.srcAccessMask = {};
        barrier.dstAccessMask = vk::AccessFlagBits::eColorAttachmentRead;

        srcStageFlags = vk::PipelineStageFlagBits::eTopOfPipe;
        dstStageFlags = vk::PipelineStageFlagBits::eColorAttachmentOutput;
    }
    else if (currentLayout == vk::ImageLayout::eColorAttachmentOptimal && targetLayout ==
        vk::ImageLayout::eShaderReadOnlyOptimal) {
        barrier.srcAccessMask = vk::AccessFlagBits::eColorAttachmentWrite;
        barrier.dstAccessMask = vk::AccessFlagBits::eShaderRead;

        srcStageFlags = vk::PipelineStageFlagBits::eColorAttachmentOutput;
        dstStageFlags = vk::PipelineStageFlagBits::eFragmentShader;
    }
    else {
        throw std::runtime_error("Unsupported layout transition");
    }

    assert(
        m_transferCommandBuffer->GetIsRecording() &&
        "Command buffer that will transfer image layout is not recording !");
    m_transferCommandBuffer->GetCommandBuffer().pipelineBarrier(
        srcStageFlags, dstStageFlags,
        {},
        0, nullptr,
        0, nullptr,
        1, &barrier
        );

}

void VulkanCore::VImage::FillWithImageData(const VulkanStructs::ImageData& imageData, bool transitionToShaderReadOnly, bool destroyCurrentImage) {

    if(destroyCurrentImage)
    {
        Resize(imageData.widht, imageData.height);
    }
    m_path = imageData.fileName;

    m_transferCommandBuffer->BeginRecording();
    // copy pixel data to the staging buffer
    Utils::Logger::LogInfoVerboseOnly("Copying image data to staging buffer");

    m_stagingBufferWithPixelData = std::make_unique<VulkanCore::VBuffer>(m_device, "<== IMAGE STAGING BUFFER ==>" + m_path);
    m_stagingBufferWithPixelData->CreateStagingBuffer(imageData.GetSize());

    memcpy(m_stagingBufferWithPixelData->MapStagingBuffer(), imageData.pixels, imageData.GetSize());
    m_stagingBufferWithPixelData->UnMapStagingBuffer();

    Utils::Logger::LogInfoVerboseOnly("Image data copied");

    // transition image to the transfer dst optimal layout so that data can be copied to it
    TransitionImageLayout(vk::ImageLayout::eUndefined, vk::ImageLayout::eTransferDstOptimal);
    CopyFromBufferToImage();

    if(!transitionToShaderReadOnly) {
        Utils::Logger::LogInfoVerboseOnly("Flag transitionToShaderReadOnly is false, this image will remain in Dst copy layout !");
        m_transferCommandBuffer->EndAndFlush(m_device.GetTransferQueue());
        return;
    }
    Utils::Logger::LogInfoVerboseOnly("Flag transitionToShaderReadOnly is true, executing transition...");
    TransitionImageLayout(vk::ImageLayout::eTransferDstOptimal, vk::ImageLayout::eShaderReadOnlyOptimal);

    // execute the recorded commands
    m_transferCommandBuffer->EndAndFlush(m_device.GetTransferQueue());

    m_device.GetTransferQueue().waitIdle();
    m_stagingBufferWithPixelData->DestroyStagingBuffer();
}

vk::DescriptorImageInfo VulkanCore::VImage::GetDescriptorImageInfo(vk::Sampler &sampler) {
    vk::DescriptorImageInfo imageInfo{};
    imageInfo.imageLayout = m_imageLayout;
    imageInfo.imageView = m_imageView;
    imageInfo.sampler = sampler;
    return imageInfo;
}


//-----------------------------
// STAGING BUFFER -> IMAGE CPY
//-----------------------------
void VulkanCore::VImage::CopyFromBufferToImage() {
    Utils::Logger::LogInfoVerboseOnly("Copying image from buffer to image...");
    vk::BufferImageCopy region = {};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = 1;

    region.imageOffset.x = 0;
    region.imageOffset.y = 0;
    region.imageOffset.z = 0;

    region.imageExtent.width = m_width;
    region.imageExtent.height = m_height;
    region.imageExtent.depth = 1;

    assert(
        m_transferCommandBuffer->GetIsRecording() && "Command buffer that will copy buffer to image is not recording, enable it using BeginRecording method");
    m_transferCommandBuffer->GetCommandBuffer().copyBufferToImage(m_stagingBufferWithPixelData->GetStagingBuffer(),
                                                                  m_imageVK, vk::ImageLayout::eTransferDstOptimal, 1,
                                                                  &region);

}

void VulkanCore::VImage::GenerateImageView() {

    vk::ImageViewCreateInfo createInfo{};
    createInfo.image = m_imageVK;
    createInfo.format = m_format;
    createInfo.viewType = vk::ImageViewType::e2D;
    createInfo.subresourceRange.aspectMask = m_aspectFlags;
    createInfo.subresourceRange.baseMipLevel = 0;
    createInfo.subresourceRange.levelCount = m_mipLevels;
    createInfo.subresourceRange.baseArrayLayer = 0;
    createInfo.subresourceRange.layerCount = 1;

    m_imageView = m_device.GetDevice().createImageView(createInfo);
    assert(m_imageView);
    Utils::Logger::LogInfoVerboseOnly("2D Image view created");

}

void VulkanCore::VImage::AllocateImage(size_t imageSize) {
    //create vulkan represetnation of the image
    VkImageCreateInfo imageInfo = {};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.width = m_width;
    imageInfo.extent.height = m_height;
    imageInfo.extent.depth = 1;
    imageInfo.mipLevels = m_mipLevels;
    imageInfo.arrayLayers = 1;
    imageInfo.format = static_cast<VkFormat>(m_format);
    imageInfo.tiling = static_cast<VkImageTiling>(vk::ImageTiling::eOptimal);
    imageInfo.initialLayout = static_cast<VkImageLayout>(vk::ImageLayout::eUndefined);
    if (m_aspectFlags & vk::ImageAspectFlagBits::eDepth) {
        imageInfo.usage = static_cast<VkImageUsageFlags>(vk::ImageUsageFlagBits::eDepthStencilAttachment);
    }
    else {
        imageInfo.usage = static_cast<VkImageUsageFlags>(vk::ImageUsageFlagBits::eTransferDst |
            vk::ImageUsageFlagBits::eSampled);
    }
    imageInfo.sharingMode = static_cast<VkSharingMode>(vk::SharingMode::eExclusive);
    imageInfo.samples = static_cast<VkSampleCountFlagBits>(vk::SampleCountFlagBits::e1);

    //m_imageVK = m_device.GetDevice().createImage(imageInfo);

    // create vma allocation
    VmaAllocationCreateInfo imageAllocationInfo = {};
    imageAllocationInfo.usage = VMA_MEMORY_USAGE_AUTO;
    imageAllocationInfo.flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
    assert(
        vmaCreateImage(m_device.GetAllocator(), &imageInfo, &imageAllocationInfo, &m_imageVMA, &m_imageAllocation,
            nullptr) == VK_SUCCESS);
    vmaSetAllocationName(m_device.GetAllocator(), m_imageAllocation, "<== IMAGE ==>");

    m_imageVK = m_imageVMA;
}


void VulkanCore::VImage::Resize(uint32_t newWidth, uint32_t newHeight) {
    m_width = newWidth;
    m_height = newHeight;
    Utils::Logger::LogInfo("Resizing the image...");
        Destroy();
        AllocateImage(m_imageSize);
        GenerateImageView();
        Utils::Logger::LogSuccess("Image resized, its data will not be preserved to preserve data call FillImageWithData() !");
}

void VulkanCore::VImage::Destroy() {
    if (!m_isSwapChainImage) {

        vmaDestroyImage(m_device.GetAllocator(), m_imageVMA, m_imageAllocation);

    }
    m_device.GetDevice().destroyImageView(m_imageView);
    Utils::Logger::LogInfoVerboseOnly("Deleted image and its image view");
}
