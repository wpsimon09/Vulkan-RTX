//
// Created by wpsimon09 on 12/10/24.
//

#include "VImage.hpp"

#include "Application/Logger/Logger.hpp"
#include "Vulkan/Global/GlobalStructs.hpp"
#include "Vulkan/Global/GlobalVariables.hpp"
#include "Vulkan/VulkanCore/Device/VDevice.hpp"
#include "stb_image/stb_image.h"

VulkanCore::VImage::VImage(const VulkanCore::VDevice &device, vk::Image image, int widht, int height,
                            uint32_t mipLevels, vk::Format format, vk::ImageAspectFlags aspecFlags):
    m_device(device), m_imageVK(image) {

    m_width = widht;
    m_height = height;
    m_mipLevels = mipLevels;
    m_format = format;
    m_aspectFlags = aspecFlags;

    m_path = "Image generated by swap chain";

    m_isSwapChainImage = true;

    GenerateImageView();
}

VulkanCore::VImage::VImage(const VulkanCore::VDevice &device,const  std::string& path,uint32_t mipLevels, vk::Format format, vk::ImageAspectFlags aspecFlags):
        m_device(device){

    m_mipLevels = mipLevels;
    m_format = format;
    m_aspectFlags = aspecFlags;
    m_isSwapChainImage = false;
    m_transferCommandBuffer = std::make_unique<VCommandBuffer>(m_device, m_device.GetTransferCommandPool());
    m_path = path;

    // this command buffer will record all commands that are needed for image to be created and execute them all at once
    m_transferCommandBuffer->BeginRecording();
    GenerateImage(path);


    // lock the ciritical section
    std::lock_guard<std::mutex> lock(m_device.DeviceMutex);
    //make buffer layout best for shader to read from
    TransitionImageLayout(vk::ImageLayout::eUndefined,vk::ImageLayout::eTransferDstOptimal);

    // fill image with image data
    CopyFromBufferToImage();

    // make buffer layout best for transition data into
    TransitionImageLayout(vk::ImageLayout::eTransferDstOptimal, vk::ImageLayout::eShaderReadOnlyOptimal);

    m_transferCommandBuffer->EndAndFlush(m_device.GetTransferQueue());

    m_device.GetTransferQueue().waitIdle();
    m_stagingBufferWithPixelData->DestroyStagingBuffer();

    GenerateImageView();
}

VulkanCore::VImage::VImage(const VulkanCore::VDevice &device, uint32_t width, uint32_t height, uint32_t mipLevels,
    vk::Format format, vk::ImageAspectFlags aspecFlags):m_device(device) {
    m_mipLevels = mipLevels;
    m_format = format;
    m_aspectFlags = aspecFlags;
    m_isSwapChainImage = false;
    m_width = width;
    m_height = height;

    m_path = "Image generated by application";

    GenerateImage("");
    GenerateImageView();
}

void VulkanCore::VImage::Resize(uint32_t newWidth, uint32_t newHeight)  {
    m_width = newWidth;
    m_height = newHeight;
    Utils::Logger::LogInfo("Resizing the image...");
    if(m_isDepthBuffer) {
        Destroy();
        GenerateImage("");
        GenerateImageView();
        Utils::Logger::LogSuccess("Image resizeed !");
    }else {
        Utils::Logger::LogError("Image is not a depth buffer and can not be resized, for now only the support for the depth buffer is resi");
    }
}

void VulkanCore::VImage::Destroy() {
    m_device.GetDevice().destroyImageView(m_imageView);
    if(!m_isSwapChainImage) {
        vmaDestroyImage(m_device.GetAllocator(), m_imageVMA, m_imageAllocation);
    }
    Utils::Logger::LogInfoVerboseOnly(  "Deleted image and its image view");
}

//------------------------------------------------------------
// ALLOCATE IMAGE , FILL WITH DATA, MAKE IT SHADER ACCESSIBLE
//------------------------------------------------------------
void VulkanCore::VImage::GenerateImage(const std::string& path) {
    Utils::Logger::LogInfoVerboseOnly("Generating image...");

    if(!path.empty()) {
        int texWidth, texHeight, texChannels;
        stbi_uc* pixels = stbi_load(path.c_str(), &texWidth, &texHeight, &texChannels, STBI_rgb_alpha);
        m_imageSize = texWidth * texHeight * 4;

        if(!pixels) {
            Utils::Logger::LogError("Failed to generate texture at path: \t" + path);
            Utils::Logger::LogInfo("Failing back to the default texture");

            pixels = stbi_load("Resources/DefaultTexture.jpg", &texWidth, &texHeight, &texChannels, STBI_rgb_alpha);
            m_imageSize = texWidth * texHeight * 4;

            if(!pixels) {
                throw std::runtime_error("Fallback to default texture failed, this should never happen !");
            }
        }

        else {
            Utils::Logger::LogInfoVerboseOnly("Image read successfully !");
        }

        m_width = texWidth;
        m_height = texHeight;

        // copy pixel data to the staging buffer
        Utils::Logger::LogInfoVerboseOnly("Copying image data to staging buffer");
        m_stagingBufferWithPixelData = std::make_unique<VulkanCore::VBuffer>(m_device);
        m_stagingBufferWithPixelData->CreateStagingBuffer(m_imageSize);
        auto mappedStagingBuffer = m_stagingBufferWithPixelData->MapStagingBuffer();
        memcpy(mappedStagingBuffer, pixels, static_cast<size_t>(m_imageSize));
        m_stagingBufferWithPixelData->UnMapStagingBuffer();
        Utils::Logger::LogInfoVerboseOnly("Image data copied");
    }else {
        Utils::Logger::LogInfoVerboseOnly("Path is empty, creating empty image based on the provided parameters ");
    }

    //create vulkan represetnation of the image
    VkImageCreateInfo imageInfo = {};
    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageInfo.imageType = VK_IMAGE_TYPE_2D;
    imageInfo.extent.width = m_width;
    imageInfo.extent.height = m_height;
    imageInfo.extent.depth = 1;
    imageInfo.mipLevels = m_mipLevels;
    imageInfo.arrayLayers = 1;
    imageInfo.format = static_cast<VkFormat>(m_format);
    imageInfo.tiling = static_cast<VkImageTiling>(vk::ImageTiling::eOptimal);
    imageInfo.initialLayout = static_cast<VkImageLayout>(vk::ImageLayout::eUndefined);
    if(m_aspectFlags & vk::ImageAspectFlagBits::eDepth) {
        imageInfo.usage = static_cast<VkImageUsageFlags>(vk::ImageUsageFlagBits::eDepthStencilAttachment);
    }
    else {
        imageInfo.usage = static_cast<VkImageUsageFlags>(vk::ImageUsageFlagBits::eTransferDst | vk::ImageUsageFlagBits::eSampled);
    }
    imageInfo.sharingMode  = static_cast<VkSharingMode>(vk::SharingMode::eExclusive);
    imageInfo.samples  = static_cast<VkSampleCountFlagBits>(vk::SampleCountFlagBits::e1);

    //m_imageVK = m_device.GetDevice().createImage(imageInfo);

    // create vma allocation
    VmaAllocationCreateInfo imageAllocationInfo = {};
    imageAllocationInfo.usage = VMA_MEMORY_USAGE_AUTO;
    imageAllocationInfo.flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
    assert(vmaCreateImage(m_device.GetAllocator(), &imageInfo, &imageAllocationInfo, &m_imageVMA, &m_imageAllocation, nullptr) == VK_SUCCESS);


    m_imageVK = m_imageVMA;
}

//--------------------------
// IMAGE LAYOUT TRANSITION
//--------------------------
void VulkanCore::VImage::TransitionImageLayout(vk::ImageLayout currentLayout, vk::ImageLayout targetLayout) {
    Utils::Logger::LogInfoVerboseOnly("Transition image layout...");

    m_imageLayout = targetLayout;
    // record
    //m_transferCommandBuffer->BeginRecording();

    vk::PipelineStageFlags srcStageFlags;
    vk::PipelineStageFlags dstStageFlags;

    vk::ImageMemoryBarrier barrier{};
    barrier.oldLayout = currentLayout;
    barrier.newLayout = targetLayout;
    barrier.srcQueueFamilyIndex = vk::QueueFamilyIgnored;
    barrier.dstQueueFamilyIndex= vk::QueueFamilyIgnored;
    barrier.image = m_imageVK;
    barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = 1;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;

    if(currentLayout==vk::ImageLayout::eUndefined && targetLayout == vk::ImageLayout::eTransferDstOptimal){
        barrier.srcAccessMask = {};
        barrier.dstAccessMask = vk::AccessFlagBits::eTransferWrite;

        srcStageFlags = vk::PipelineStageFlagBits::eTopOfPipe;
        dstStageFlags = vk::PipelineStageFlagBits::eTransfer;
    }
    else if(currentLayout == vk::ImageLayout::eTransferDstOptimal && targetLayout == vk::ImageLayout::eShaderReadOnlyOptimal) {
        barrier.srcAccessMask = vk::AccessFlagBits::eTransferWrite;
        barrier.dstAccessMask = vk::AccessFlagBits::eShaderRead;

        srcStageFlags = vk::PipelineStageFlagBits::eTransfer;
        dstStageFlags = vk::PipelineStageFlagBits::eFragmentShader;
    }
    else {
        throw std::runtime_error("Unsupported layout transition");
    }

    assert(m_transferCommandBuffer->GetIsRecording() && "Command buffer that will transfer image layout is not recording !");
    m_transferCommandBuffer->GetCommandBuffer().pipelineBarrier(
      srcStageFlags, dstStageFlags,
          {},
          0, nullptr,
          0, nullptr,
          1, &barrier
      );

}

vk::DescriptorImageInfo VulkanCore::VImage::GetDescriptorImageInfo(vk::Sampler &sampler) {
    vk::DescriptorImageInfo imageInfo{};
    imageInfo.imageLayout = m_imageLayout;
    imageInfo.imageView = m_imageView;
    imageInfo.sampler = sampler;
    return imageInfo;
}


//-----------------------------
// STAGING BUFFER -> IMAGE CPY
//-----------------------------
void VulkanCore::VImage::CopyFromBufferToImage() {
    Utils::Logger::LogInfoVerboseOnly("Copying image from buffer to image...");
    vk::BufferImageCopy region = {};
    region.bufferOffset = 0;
    region.bufferRowLength = 0;
    region.bufferImageHeight = 0;

    region.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
    region.imageSubresource.mipLevel = 0;
    region.imageSubresource.baseArrayLayer = 0;
    region.imageSubresource.layerCount = 1;

    region.imageOffset.x = 0;;
    region.imageOffset.y = 0;;
    region.imageOffset.z = 0;;

    region.imageExtent.width = m_width;
    region.imageExtent.height = m_height;
    region.imageExtent.depth = 1;

    assert(m_transferCommandBuffer->GetIsRecording() && "Command buffer that will copy buffer to image is not recording");
    m_transferCommandBuffer->GetCommandBuffer().copyBufferToImage(m_stagingBufferWithPixelData->GetStagingBuffer(), m_imageVK, vk::ImageLayout::eTransferDstOptimal,1, &region);
}

void VulkanCore::VImage::GenerateImageView() {
    if(m_aspectFlags == vk::ImageAspectFlagBits::eDepth) {
        m_isDepthBuffer = true;
    }

    vk::ImageViewCreateInfo createInfo{};
    createInfo.image = m_imageVK;
    createInfo.format = m_format;
    createInfo.viewType = vk::ImageViewType::e2D;
    createInfo.subresourceRange.aspectMask = m_aspectFlags;
    createInfo.subresourceRange.baseMipLevel = 0;
    createInfo.subresourceRange.levelCount = m_mipLevels;
    createInfo.subresourceRange.baseArrayLayer = 0;
    createInfo.subresourceRange.layerCount = 1;

    m_imageView = m_device.GetDevice().createImageView(createInfo);
    assert(m_imageView);
    Utils::Logger::LogInfoVerboseOnly("2D Image view created" );

}

