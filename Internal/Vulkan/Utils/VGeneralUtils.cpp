//
// Created by wpsimon09 on 27/09/24.
//

#include "VGeneralUtils.hpp"

#include <thread>
#include <bits/fs_fwd.h>

#include "Application/Logger/Logger.hpp"
#include "Application/VertexArray/VertexArray.hpp"
#include "Vulkan/VulkanCore/Buffer/VBuffer.hpp"
#include "Vulkan/VulkanCore/CommandBuffer/VCommandBuffer.hpp"
#include "Vulkan/VulkanCore/CommandBuffer/VCommandPool.hpp"
#include "Vulkan/VulkanCore/Device/VDevice.hpp"
#include "Vulkan/VulkanCore/SwapChain/VSwapChain.hpp"
#include "Application/Structs/ApplicationStructs.hpp"

uint32_t VulkanUtils::FindQueueFamily(const std::vector<vk::QueueFamilyProperties> &queueFamilyProperties,
                                      vk::QueueFlagBits queueType) {
    //select just the queue fmily index that supports graphics operations
    std::vector<vk::QueueFamilyProperties>::const_iterator graphicsQueueFamilyProperty = std::find_if(
        queueFamilyProperties.begin(),
        queueFamilyProperties.end(),
        [queueType]( vk::QueueFamilyProperties const & qfp ) { return qfp.queueFlags & queueType; } );

    assert(graphicsQueueFamilyProperty != queueFamilyProperties.end());
    auto queueFamilyIndex =  static_cast<uint32_t> (std::distance(queueFamilyProperties.begin(), graphicsQueueFamilyProperty));
    Utils::Logger::LogInfoVerboseOnly("Found graphics queue family at index: " + std::to_string(queueFamilyIndex));
    return queueFamilyIndex;
}

vk::ImageView VulkanUtils::GenerateImageView(const vk::Device &logicalDevice, const vk::Image &image,
    uint32_t mipLevels, vk::Format format, vk::ImageAspectFlags aspecFlags) {
    vk::ImageViewCreateInfo createInfo{};
    createInfo.image = image;
    createInfo.format = format;
    createInfo.viewType = vk::ImageViewType::e2D;
    createInfo.subresourceRange.aspectMask = aspecFlags;
    createInfo.subresourceRange.baseMipLevel = 0;
    createInfo.subresourceRange.levelCount = mipLevels;
    createInfo.subresourceRange.baseArrayLayer = 0;
    createInfo.subresourceRange.layerCount = 1;

    vk::ImageView imageView = logicalDevice.createImageView(createInfo);
    assert(imageView != VK_NULL_HANDLE);
    Utils::Logger::LogInfoVerboseOnly("2D Image view created [this message was generated by utility function]");
    return imageView;
}

void VulkanUtils::GetVertexBindingAndAttributeDescription(vk::VertexInputBindingDescription &bindingDescription,
    std::vector<vk::VertexInputAttributeDescription> &attributeDescription) {
    bindingDescription.binding = 0;
    bindingDescription.stride = sizeof(ApplicationCore::Vertex);
    bindingDescription.inputRate = vk::VertexInputRate::eVertex;

    attributeDescription.resize(3);

    // FOR POSITION
    attributeDescription[0].binding = 0;
    attributeDescription[0].location = 0;
    attributeDescription[0].format = vk::Format::eR32G32B32Sfloat;
    attributeDescription[0].offset = offsetof(ApplicationCore::Vertex, position);

    // NORMALS
    attributeDescription[1].binding = 0;
    attributeDescription[1].location = 1;
    attributeDescription[1].format = vk::Format::eR32G32B32Sfloat;
    attributeDescription[1].offset = offsetof(ApplicationCore::Vertex, normal);

    // uv
    attributeDescription[2].binding = 0;
    attributeDescription[2].location = 2;
    attributeDescription[2].format = vk::Format::eR32G32Sfloat;
    attributeDescription[2].offset = offsetof(ApplicationCore::Vertex, uv);
}

void VulkanUtils::CopyBuffers(const VulkanCore::VDevice &device, const vk::Buffer &srcBuffer,
    const vk::Buffer &dstBuffer, vk::DeviceSize size) {
    auto cmdBuffer = VulkanCore::VCommandBuffer(device, device.GetTransferCommandPool());
    Utils::Logger::LogInfoVerboseOnly("Copying buffers...");

    cmdBuffer.BeginRecording();

    vk::BufferCopy bufferCopy{};
    bufferCopy.srcOffset = 0;
    bufferCopy.dstOffset = 0;
    bufferCopy.size = size;

    cmdBuffer.GetCommandBuffer().copyBuffer(srcBuffer, dstBuffer, bufferCopy);

    cmdBuffer.EndRecording();

    vk::SubmitInfo submitInfo{};
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &cmdBuffer.GetCommandBuffer();

    assert(device.GetTransferQueue().submit(1, &submitInfo, nullptr) == vk::Result::eSuccess);
    Utils::Logger::LogSuccess("Buffer copy completed !");
}

VulkanStructs::ImageData VulkanUtils::LoadImage(const std::string &path) {

    VulkanStructs::ImageData imageData{};

    imageData.pixels = reinterpret_cast<uint32_t*>(stbi_load(path.c_str(), &imageData.widht, &imageData.height, &imageData.channels, STBI_rgb_alpha));
    imageData.channels = 4;
    imageData.fileName = path;

    if (!imageData.pixels) {
        Utils::Logger::LogError("Failed to generate texture at path: \t" + path);
        Utils::Logger::LogInfo("Failing back to the default texture");

        imageData.pixels = reinterpret_cast<uint32_t*>(stbi_load("Resources/DefaultTexture.jpg", &imageData.widht, &imageData.height, &imageData.channels, STBI_rgb_alpha));
        imageData.channels = 4;
        imageData.fileName = path;

        if (!imageData.pixels) {
            throw std::runtime_error("Fallback to default texture failed, this should never happen !");
        }
    }else {
        Utils::Logger::LogSuccess("Image at path:\t" + path + "\n read successfully");
    }
      //-> to test the concurrency uncomment this line
    //std::this_thread::sleep_for(std::chrono::seconds(7));

    return imageData;

}

VulkanStructs::ImageData VulkanUtils::LoadImage(const TextureBufferInfo& data, const std::string& textureID)
{
    VulkanStructs::ImageData imageData{};

    imageData.pixels = reinterpret_cast<uint32_t*>(stbi_load_from_memory(reinterpret_cast<stbi_uc const*>(data.data), static_cast<int>(data.size), &imageData.widht, &imageData.height, &imageData.channels, STBI_rgb_alpha));
    imageData.channels = 4;
    imageData.fileName = textureID;

    if (!imageData.pixels) {

        Utils::Logger::LogError("Failed to generate texture that was loaded from memory, textureID was:" + textureID);
        Utils::Logger::LogInfo("Failing back to the default texture");

        imageData.pixels = reinterpret_cast<uint32_t*>(stbi_load("Resources/DefaultTexture.jpg", &imageData.widht, &imageData.height, &imageData.channels, STBI_rgb_alpha));
        imageData.channels = 4;
        imageData.fileName = "Resources/DefaultTexture.jpg";

        if (!imageData.pixels) {
            throw std::runtime_error("Fallback to default texture failed, this should never happen !");
        }
    }else {
        Utils::Logger::LogSuccess("Image from buffer with ID:\t" + textureID + "\n read successfully");
    }

    //-> to test the concurrency uncomment this line
    //std::this_thread::sleep_for(std::chrono::seconds(7));

    return imageData;
}

std::string VulkanUtils::BufferUsageFlagToString(vk::BufferUsageFlagBits usage)
{
    switch (usage)
    {
        case vk::BufferUsageFlagBits::eTransferSrc: {
                return "Transfer Source";
        }
        case vk::BufferUsageFlagBits::eTransferDst: {
                return "Transfer Destination";
        }
        case vk::BufferUsageFlagBits::eUniformTexelBuffer: {
                return "Uniform Texel Buffer";
        }
        case vk::BufferUsageFlagBits::eStorageTexelBuffer: {
                return "Storage Texel Buffer";
        }
        case vk::BufferUsageFlagBits::eUniformBuffer: {
                return "Uniform Buffer";
        }
        case vk::BufferUsageFlagBits::eStorageBuffer: {
                return "Storage Buffer";
        }
        case vk::BufferUsageFlagBits::eIndexBuffer: {
                return "Index Buffer";
        }
        case vk::BufferUsageFlagBits::eVertexBuffer: {
                return "Vertex Buffer";
        }
        case vk::BufferUsageFlagBits::eIndirectBuffer: {
                return "Indirect Buffer";
        }
        case vk::BufferUsageFlagBits::eShaderDeviceAddress: {
                return "Shader Device Address";
        }
        case vk::BufferUsageFlagBits::eVideoDecodeSrcKHR: {
                return "Video Decode Source KHR";
        }
        case vk::BufferUsageFlagBits::eVideoDecodeDstKHR: {
                return "Video Decode Destination KHR";
        }
        case vk::BufferUsageFlagBits::eTransformFeedbackBufferEXT: {
                return "Transform Feedback Buffer EXT";
        }
        case vk::BufferUsageFlagBits::eTransformFeedbackCounterBufferEXT: {
                return "Transform Feedback Counter Buffer EXT";
        }
        case vk::BufferUsageFlagBits::eConditionalRenderingEXT: {
                return "Conditional Rendering EXT";
        }
        default: {
                return "Unknown Buffer Usage";
        }
    }

}

glm::mat4 VulkanUtils::FastGLTFToGLMMat4(fastgltf::math::fmat4x4& matrix)
{
    glm::mat4 newMatrix;
    for (int row = 0; row < 4; ++row)
        for (int col = 0; col < 4; ++col)
            newMatrix[row][col] = matrix[row][col];
    return newMatrix;
}

std::pair<vk::Result, uint32_t> VulkanUtils::SwapChainNextImageKHRWrapper(const VulkanCore::VDevice &device,
                                                                          const VulkanCore::VSwapChain &swapChain, uint64_t timeOut, const VulkanCore::VSyncPrimitive<vk::Semaphore>& semaphore,
                                                                          VulkanCore::VSyncPrimitive<vk::Fence> *fence) {
    uint32_t image_index;
    auto result = static_cast<vk::Result>(vkAcquireNextImageKHR(
            device.GetDevice(),
            swapChain.GetSwapChain(),
            timeOut,
            semaphore.GetSyncPrimitive(),
            nullptr,
            &image_index
        ));
    return std::make_pair(result, image_index);
}

vk::Result VulkanUtils::PresentQueueWrapper(vk::Queue queue, const vk::PresentInfoKHR &presentInfo) {
    auto result = static_cast<vk::Result>(vkQueuePresentKHR(queue,reinterpret_cast<const VkPresentInfoKHR*>(&presentInfo)));
    return result;
}

std::string VulkanUtils::random_string(size_t length)
{
    {
        auto randchar = []() -> char
        {
            const char charset[] =
            "0123456789"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz";
            const size_t max_index = (sizeof(charset) - 1);
            return charset[ rand() % max_index ];
        };
        std::string str(length,0);
        std::generate_n( str.begin(), length, randchar );
        return str;
    }
}
