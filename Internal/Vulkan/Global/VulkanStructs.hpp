//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Application/Rendering/Material/Material.hpp"
#include "glm/glm.hpp"
#include "VMA/vk_mem_alloc.h"

#ifndef BUFFER_SIZE
    #define BUFFER_SIZE 16777216 // 16MB
#endif


namespace VulkanStructs
{
    struct ImageData
    {
        uint32_t* pixels;
        int widht, height, channels;
        std::string fileName = "generated by Vulkan";

        size_t GetSize() const {
            return widht * height * channels;
        }
        void Clear() const {
            stbi_image_free(pixels);
        }
    };

    struct Bounds
    {
        glm::vec3 origin;
        glm::vec3 extents;
        glm::vec3 max = {-1.5f, -1.5f, -1.5f}; // min point in world space
        glm::vec3 min = {1.5f, 1.5f, 1.5f}; // max point in world space
        std::array<glm::vec3, 8> corners = {
            glm::vec3 { 1, 1, 1 },
            glm::vec3 { 1, 1, -1 },
            glm::vec3 { 1, -1, 1 },
            glm::vec3 { 1, -1, -1 },
            glm::vec3 { -1, 1, 1 },
            glm::vec3 { -1, 1, -1 },
            glm::vec3 { -1, -1, 1 },
            glm::vec3 { -1, -1, -1 },

        };

        void ProjectToWorld(const glm::mat4& modelMatrix)
        {
            for (auto corner : corners)
            {
                corner = modelMatrix * glm::vec4(origin + (corner * extents), 1.0f);

                min = glm::min(min, corner);
                max = glm::max(max, corner);
            }
        }

        float radius;
    };



    struct RenderingMetaData
    {
        bool bMainLightPass = true;
        bool bRTXPass = false;
        bool bEditorBillboardPass = false;

        float minZ = 10000;
        glm::mat4 view;
        glm::mat4 projection;

        bool operator==(const RenderingMetaData& other) const
        {
            return bMainLightPass == other.bMainLightPass && bRTXPass == other.bRTXPass && bEditorBillboardPass == other.bEditorBillboardPass;
        }

        bool IsRenderingContextMainLightPassOnly() const {return bMainLightPass && !bRTXPass && !bEditorBillboardPass;}
        bool IsRenderingContextRTXOnly() const {return !bMainLightPass && bRTXPass && !bEditorBillboardPass;}
        bool IsRenderingContextBilboardOnly() const {return !bMainLightPass && !bRTXPass && bEditorBillboardPass;}
    };

    struct RenderingStatistics
    {
        int DrawCallCount = 0;
    };

    // holds offset to the larger buffer that is in GPU to prevent fragmentation
    struct GPUSubBufferInfo
    {
        vk::DeviceSize size;
        vk::DeviceSize offset;

        vk::Buffer buffer;
    };

    struct MeshData
    {
        GPUSubBufferInfo vertexData;
        GPUSubBufferInfo indexData;
        GPUSubBufferInfo vertexData_BB;
        GPUSubBufferInfo indexData_BB;
        Bounds bounds;
    };

    struct GPUBufferInfo
    {
        vk::DeviceSize size = BUFFER_SIZE;
        vk::DeviceSize currentOffset = 0;
        vk::DeviceSize copyOffSet = 0;

        vk::Buffer bufferVK;
        vk::BufferUsageFlags usageFlags;
        VkBuffer bufferVMA;
        VmaAllocation allocationVMA;

        int ID;

        vk::DeviceSize GetAvailableSize() const { return (currentOffset >= size) ? 0 : (size - currentOffset); }
        bool WillNewBufferFit(vk::DeviceSize size) const { return size <= GetAvailableSize(); }
    };

    struct StagingBufferInfo
    {
        void *mappedPointer;
        vk::DeviceSize size;
        vk::DeviceSize dstOffset;
        VmaAllocation m_stagingAllocation;
        VkBuffer m_stagingBufferVMA;
        vk::Buffer m_stagingBufferVK;

        VkBuffer copyDstBuffer;
    };

struct DrawCallData
{
    uint32_t indexCount = 0;
    uint32_t firstIndex = 0;
    uint32_t indexCount_BB = 36;
    uint32_t instanceCount = 1;
    mutable int drawCallID = 0;

    Bounds* bounds = nullptr;
    MeshData* meshData = nullptr;

    glm::mat4 modelMatrix;
    glm::vec3 position;

    float depth = -1.0f;
    bool renderOutline = false;
    bool isEditorBilboard = false;

    std::shared_ptr<ApplicationCore::Material> material;
};

    struct RenderContext
    {
        RenderingMetaData metaData;
        // Pipeline
        std::vector<DrawCallData> DrawCalls;

        void ExtractDepthValues(glm::vec3& cameraPosition)
        {
            for (auto &drawCall: DrawCalls)
                drawCall.depth = glm::length(cameraPosition - drawCall.position);
        }

        static bool CompareByDeptDesc(const DrawCallData& DrawCallA, const DrawCallData& DrawCallB)
        {
            return DrawCallA.depth > DrawCallB.depth;
        }

        static bool CompareByDeptAsc(const DrawCallData& DrawCallA, const DrawCallData& DrawCallB)
        {
            return DrawCallA.depth< DrawCallB.depth;
        }


    };

}

#endif //VULKANSTRUCTS_HPP
