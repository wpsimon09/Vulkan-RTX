//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Vulkan/Global/GlobalVulkanEnums.hpp"
#include "VMA/vk_mem_alloc.h"
#include "glm/glm.hpp"
#include "Application/Rendering/Material/PBRMaterial.hpp"
#include "Vulkan/Utils/VUniformBufferManager/UnifromsRegistry.hpp"

#include <map>



namespace VulkanUtils {
class VRasterEffect;
}

namespace ApplicationCore {
class EffectsLibrary;
}

namespace LightStructs {
struct SceneLightInfo;
}

namespace VulkanStructs {
template <typename T = uint32_t>
struct VImageData
{
    T*           pixels;
    int          widht, height, channels;
    std::string  fileName   = "generated by Vulkan";
    EImageSource sourceType = EImageSource::Generated;
    vk::Format   format     = vk::Format::eR8G8B8A8Unorm;

    std::optional<size_t> offset = 0;


    size_t GetSize() const
    {
        if(std::is_same<T, uint32_t>::value)
            return widht * height * sizeof(T);
        else if(std::is_same<T, float>::value)
            return widht * height * channels * sizeof(float);
        else
            throw std::invalid_argument("Wrong image format supplied, supported formats are float and uint32_t");
    }
    void Clear() const
    {
        if(pixels && EImageSource::File)
        {
            stbi_image_free(pixels);
        }
    }
};


struct VBounds
{
    glm::vec3                origin;
    glm::vec3                extents;
    glm::vec3                max     = {-1.5f, -1.5f, -1.5f};  // min point in world space
    glm::vec3                min     = {1.5f, 1.5f, 1.5f};     // max point in world space
    std::array<glm::vec3, 8> corners = {
        glm::vec3{1, 1, 1},  glm::vec3{1, 1, -1},  glm::vec3{1, -1, 1},  glm::vec3{1, -1, -1},
        glm::vec3{-1, 1, 1}, glm::vec3{-1, 1, -1}, glm::vec3{-1, -1, 1}, glm::vec3{-1, -1, -1},

    };

    void ProjectToWorld(const glm::mat4& modelMatrix)
    {
        for(auto corner : corners)
        {
            corner = modelMatrix * glm::vec4(origin + (corner * extents), 1.0f);

            min = glm::min(min, corner);
            max = glm::max(max, corner);
        }
    }

    float radius;
};


struct VRenderingStatistics
{
    int DrawCallCount = 0;
};

// holds offset to the larger buffer that is in GPU to prevent fragmentation
struct VGPUSubBufferInfo
{
    vk::DeviceSize size;
    vk::DeviceSize offset;

    vk::Buffer        buffer;
    int               ID;
    int               BufferID;
    vk::DeviceAddress bufferAddress;

    bool operator==(const VGPUSubBufferInfo& other) const { return BufferID == other.BufferID; }

    bool operator!=(const VGPUSubBufferInfo& other) const { return BufferID != other.BufferID; }
};
;

struct VMeshData
{
    VGPUSubBufferInfo vertexData;
    VGPUSubBufferInfo indexData;
    VGPUSubBufferInfo vertexData_BB;
    VGPUSubBufferInfo indexData_BB;
    VBounds           bounds;
};

struct VGPUBufferInfo
{
    vk::DeviceSize size          = 0;
    vk::DeviceSize currentOffset = 0;
    vk::DeviceSize copyOffSet    = 0;
    vk::DeviceSize baseOffset    = 0;

    vk::Buffer           bufferVK;
    vk::BufferUsageFlags usageFlags;
    vk::DeviceAddress    bufferAddress;
    VkBuffer             bufferVMA;
    VmaAllocation        allocationVMA;

    int ID;
    vk::DeviceSize GetAvailableSize() const { return (currentOffset >= size) ? 0 : (size - currentOffset); }
    bool           WillNewBufferFit(vk::DeviceSize size) const { return size <= GetAvailableSize(); }
};

template <typename T>
struct VReadBackBufferInfo
{
    std::vector<T> data;
    int            bufferID;
    size_t         size;
};

struct VStagingBufferInfo
{
    void*          mappedPointer;
    vk::DeviceSize size;
    vk::DeviceSize dstOffset;
    VmaAllocation  m_stagingAllocation;
    VkBuffer       m_stagingBufferVMA;
    vk::Buffer     m_stagingBufferVK;

    VkBuffer copyDstBuffer;
};

struct VDrawCallData
{
    uint32_t indexCount    = 0;
    uint32_t firstIndex    = 0;
    uint32_t indexCount_BB = 36;
    uint32_t instanceCount = 1;

    VGPUSubBufferInfo* vertexData = nullptr;
    VGPUSubBufferInfo* indexData  = nullptr;
    VBounds*           bounds     = nullptr;


    mutable int drawCallID = 0;

    glm::mat4 modelMatrix;
    glm::vec3 position;

    float depth = -1.0f;

    unsigned long key = 0;

    bool inDepthPrePass = true;
    bool selected       = false;

    ApplicationCore::BaseMaterial*              material;
    std::shared_ptr<VulkanUtils::VRasterEffect> effect;

    /**
    friend bool operator==(const VDrawCallData& lhs, const ObjectDataUniform& rhs)
    {
        if(auto* lhsPBRMat = dynamic_cast<ApplicationCore::PBRMaterial*>(lhs.material))
        {
            auto& lhsMatDescription = lhsPBRMat->GetMaterialDescription();
            auto& rhsMatDescription = rhs.material;

            return lhsMatDescription.features == rhsMatDescription.features
                   && lhsMatDescription.values == rhsMatDescription.values && lhs.modelMatrix == rhs.model
                   && lhs.position == rhs.position;
        }
        else
        {
            return lhs.modelMatrix == rhs.model && lhs.position == rhs.position;
        }
    }

    friend bool operator!=(const VDrawCallData& lhs, const ObjectDataUniform& rhs) { return !(lhs == rhs); }
    */
};

/**
 * Struct that represent single descriptor sets it holds:
 *  - its layout
 *  - separate sets per frame in flight
 *  - writes per set, each write is accessed by the "current frame" variable and binding
 *  example writes[currentFrame = 0 ][binding = 1] retrieves write for binding 1 and frame 0 
 */
struct VDescriptorSet
{
    std::vector<vk::DescriptorSet> sets;  // per frame in flight
    vk::DescriptorSetLayout        layout; // set layout
    std::map<uint32_t, std::map<int, vk::WriteDescriptorSet>> writes;  // writes are per frame in flight, map key is the frame and
                                                                     // value is the vector of writes, second map is for binding/write relations
};


}  // namespace VulkanStructs

#endif  //VULKANSTRUCTS_HPP
