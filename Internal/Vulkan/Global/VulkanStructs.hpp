//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Application/Rendering/Material/Material.hpp"
#include "glm/glm.hpp"
#include "VMA/vk_mem_alloc.h"

#ifndef BUFFER_SIZE
    #define BUFFER_SIZE 16777216 // 16MB
#endif


namespace VulkanStructs
{
    struct ImageData
    {
        uint32_t* pixels;
        int widht, height, channels;
        std::string fileName = "generated by Vulkan";

        size_t GetSize() const {
            return widht * height * channels;
        }
        void Clear() const {
            stbi_image_free(pixels);
        }
    };

    struct Bounds
    {
        glm::vec3 origin;
        glm::vec3 extents;
        float radius;
    };

    struct DrawCallData
    {
        uint32_t indexCount = 0;
        uint32_t firstIndex =0;

        VkBuffer vertexBuffer;
        VkBuffer indexBuffer;

        VkBuffer AABBVertexBuffer;
        VkBuffer AABBIndexBuffer;
        uint32_t AABBIndexCount = 0;

        glm::mat4& modelMatrix;
        uint32_t instanceCount = 1;
        Bounds *bounds;
        bool renderOutline = false;
        // material descriptor
        std::shared_ptr<ApplicationCore::Material> material;



    };

    struct RenderingMetaData
    {
        bool bRasterPass = true;
        bool bRTXPass = false;

        bool operator==(const RenderingMetaData& other) const
        {
            return bRasterPass == other.bRasterPass && bRTXPass == other.bRTXPass;
        }
    };

    struct RenderContext
    {
        RenderingMetaData metaData;
        // Pipeline
        std::vector<DrawCallData> DrawCalls;
    };

    struct RenderingStatistics
    {
        int DrawCallCunt = 0;
    };

    struct BufferInfo
    {
        vk::DeviceSize size;
        vk::DeviceSize offset;
        vk::Buffer buffer;
    };

    struct BufferAllocationInfo
    {
        vk::DeviceSize size = BUFFER_SIZE;
        vk::DeviceSize currentOffset = 0;
        vk::Buffer bufferVK;
        vk::BufferUsageFlags usageFlags;
        VkBuffer bufferVMA;
        VmaAllocation allocationVMA;

        int ID;

        vk::DeviceSize GetAvailableSize() {return size - currentOffset;};
    };

    struct StagingBufferAllocationInfo
    {
        void *mappedPointer;
        vk::DeviceSize size;
        VmaAllocation m_stagingAllocation;
        VkBuffer m_stagingBufferVMA;
        vk::Buffer m_stagingBufferVK;

        VkBuffer copyDstBuffer;
    };

}

#endif //VULKANSTRUCTS_HPP
