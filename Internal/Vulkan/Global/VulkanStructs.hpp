//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <unordered_map>
#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Application/Rendering/Material/Material.hpp"
#include "glm/glm.hpp"
#include "VMA/vk_mem_alloc.h"

#ifndef BUFFER_SIZE
    #define BUFFER_SIZE 16777216 // 16MB
#endif


namespace VulkanStructs
{
    struct ImageData
    {
        uint32_t* pixels;
        int widht, height, channels;
        std::string fileName = "generated by Vulkan";

        size_t GetSize() const {
            return widht * height * channels;
        }
        void Clear() const {
            stbi_image_free(pixels);
        }
    };

    struct Bounds
    {
        glm::vec3 origin;
        glm::vec3 extents;
        glm::vec3 max = {-1.5f, -1.5f, -1.5f}; // min point in world space
        glm::vec3 min = {1.5f, 1.5f, 1.5f}; // max point in world space
        std::array<glm::vec3, 8> corners = {
            glm::vec3 { 1, 1, 1 },
            glm::vec3 { 1, 1, -1 },
            glm::vec3 { 1, -1, 1 },
            glm::vec3 { 1, -1, -1 },
            glm::vec3 { -1, 1, 1 },
            glm::vec3 { -1, 1, -1 },
            glm::vec3 { -1, -1, 1 },
            glm::vec3 { -1, -1, -1 },

        };

        void ProjectToWorld(const glm::mat4& modelMatrix)
        {
            for (auto corner : corners)
            {
                corner = modelMatrix * glm::vec4(origin + (corner * extents), 1.0f);

                min = glm::min(min, corner);
                max = glm::max(max, corner);
            }
        }

        float radius;
    };



    struct RenderingMetaData
    {
        bool bMainLightPass = true;
        bool bRTXPass = false;
        bool bEditorBillboardPass = false;

        bool operator==(const RenderingMetaData& other) const
        {
            return bMainLightPass == other.bMainLightPass && bRTXPass == other.bRTXPass && bEditorBillboardPass == other.bEditorBillboardPass;
        }

        bool IsRenderingContextMainLightPassOnly() const {return bMainLightPass && !bRTXPass && !bEditorBillboardPass;}
        bool IsRenderingContextRTXOnly() const {return !bMainLightPass && bRTXPass && !bEditorBillboardPass;}
        bool IsRenderingContextBilboardOnly() const {return !bMainLightPass && !bRTXPass && bEditorBillboardPass;}
    };

    struct RenderingStatistics
    {
        int DrawCallCount = 0;
    };

    // holds offset to the larger buffer that is in GPU to prevent fragmentation
    struct GPUSubBufferInfo
    {
        vk::DeviceSize size;
        vk::DeviceSize offset;

        vk::Buffer buffer;
    };

    struct MeshData
    {
        GPUSubBufferInfo vertexData;
        GPUSubBufferInfo indexData;
        GPUSubBufferInfo vertexData_BB;
        GPUSubBufferInfo indexData_BB;
        Bounds bounds;
    };

    struct GPUBufferInfo
    {
        vk::DeviceSize size = BUFFER_SIZE;
        vk::DeviceSize currentOffset = 0;
        vk::DeviceSize copyOffSet = 0;

        vk::Buffer bufferVK;
        vk::BufferUsageFlags usageFlags;
        VkBuffer bufferVMA;
        VmaAllocation allocationVMA;

        int ID;

        vk::DeviceSize GetAvailableSize() const { return (currentOffset >= size) ? 0 : (size - currentOffset); }
        bool WillNewBufferFit(vk::DeviceSize size) const { return size <= GetAvailableSize(); }
    };

    struct StagingBufferInfo
    {
        void *mappedPointer;
        vk::DeviceSize size;
        vk::DeviceSize dstOffset;
        VmaAllocation m_stagingAllocation;
        VkBuffer m_stagingBufferVMA;
        vk::Buffer m_stagingBufferVK;

        VkBuffer copyDstBuffer;
    };

struct DrawCallData
{
    uint32_t indexCount = 0;
    uint32_t firstIndex = 0;
    uint32_t indexCount_BB = 36;
    uint32_t instanceCount = 1;
    mutable int drawCallID = 0;

    Bounds* bounds = nullptr;
    MeshData* meshData = nullptr;

    glm::mat4 modelMatrix;
    glm::vec3 position;

    float depth = -1.0f;
    bool renderOutline = false;
    bool isEditorBilboard = false;

    std::shared_ptr<ApplicationCore::Material> material;
};

    struct RenderContext
    {
        // all draw calls that can be inside the egine
        // TODO: maybe add unordered map instead of vector according ot this
        // @link: https://realtimecollisiondetection.net/blog/?p=86

        glm::mat4 view{};
        glm::mat4 projection{};

        std::pair<RenderingMetaData, std::vector<DrawCallData>> MainLightPass;
        std::pair<RenderingMetaData, std::vector<DrawCallData>> EditorBillboardPass;
        std::pair<RenderingMetaData, std::vector<DrawCallData>> SelectedGeometryPass;
        std::pair<RenderingMetaData, std::vector<DrawCallData>> RayTracingPlanePass;

        void ExtractDepthValues(glm::vec3& cameraPosition)
        {
            for (auto &drawCall: MainLightPass.second)
                drawCall.depth = glm::length(cameraPosition - drawCall.position);
        }

        static bool CompareByDeptDesc(const DrawCallData& DrawCallA, const DrawCallData& DrawCallB)
        {
            return DrawCallA.depth > DrawCallB.depth;
        }

        static bool CompareByDeptAsc(const DrawCallData& DrawCallA, const DrawCallData& DrawCallB)
        {
            return DrawCallA.depth< DrawCallB.depth;
        }

        RenderContext(): MainLightPass(), EditorBillboardPass(), SelectedGeometryPass(), RayTracingPlanePass()
        {
            MainLightPass.first.bEditorBillboardPass = false;
            MainLightPass.first.bMainLightPass = true;
            MainLightPass.first.bRTXPass= false;

            EditorBillboardPass.first.bEditorBillboardPass = true;
            EditorBillboardPass.first.bRTXPass = false;
            EditorBillboardPass.first.bMainLightPass = false;

            RayTracingPlanePass.first.bRTXPass= true;
            RayTracingPlanePass.first.bEditorBillboardPass = false;
            RayTracingPlanePass.first.bMainLightPass = false;
        }

        void GetAllDrawCall(std::vector<DrawCallData>& outDrawCalls)
        {
            outDrawCalls.clear();
            outDrawCalls.reserve(
                MainLightPass.second.size() +
                EditorBillboardPass.second.size() +
                SelectedGeometryPass.second.size() +
                RayTracingPlanePass.second.size()
            );

            outDrawCalls.insert(outDrawCalls.end(), MainLightPass.second.begin(), MainLightPass.second.end());
            outDrawCalls.insert(outDrawCalls.end(), EditorBillboardPass.second.begin(), EditorBillboardPass.second.end());
            outDrawCalls.insert(outDrawCalls.end(), SelectedGeometryPass.second.begin(), SelectedGeometryPass.second.end());
            outDrawCalls.insert(outDrawCalls.end(), RayTracingPlanePass.second.begin(), RayTracingPlanePass.second.end());
        }

        void AddDrawCall(const RenderingMetaData& drawCallMetaDat,DrawCallData& DrawCall)
        {
            if (drawCallMetaDat == MainLightPass.first) MainLightPass.second.push_back(DrawCall);
            if (drawCallMetaDat == RayTracingPlanePass.first) RayTracingPlanePass.second.push_back(DrawCall);
            if (drawCallMetaDat == EditorBillboardPass.first) EditorBillboardPass.second.push_back(DrawCall);
        }

        void ResetAllDrawCalls()
        {
            MainLightPass.second.clear();
            EditorBillboardPass.second.clear();
            SelectedGeometryPass.second.clear();
            RayTracingPlanePass.second.clear();
        }
    };

}

#endif //VULKANSTRUCTS_HPP
