//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Application/Rendering/Material/Material.hpp"
#include "glm/glm.hpp"

namespace VulkanStructs
{
    struct ImageData
    {
        uint32_t* pixels;
        int widht, height, channels;
        std::string fileName = "generated by Vulkan";

        size_t GetSize() const {
            return widht * height * channels;
        }
        void Clear() const {
            stbi_image_free(pixels);
        }
    };

    struct Bounds
    {
        glm::vec3 origin;
        glm::vec3 extents;
        float radius;
    };

    struct DrawCallData
    {
        uint32_t indexCount = 0;
        uint32_t firstIndex =0;

        VkBuffer vertexBuffer;
        VkBuffer indexBuffer;

        VkBuffer AABBVertexBuffer;
        VkBuffer AABBIndexBuffer;
        uint32_t AABBIndexCount = 0;

        glm::mat4& modelMatrix;
        uint32_t instanceCount = 1;
        Bounds *bounds;
        bool renderOutline = false;
        // material descriptor
        std::shared_ptr<ApplicationCore::Material> material;

        DrawCallData(const VkBuffer& vertex, const VkBuffer& index, glm::mat4& model): vertexBuffer(vertex), indexBuffer(index), modelMatrix(model)
        {

        }
    };

    struct RenderingMetaData
    {
        bool bRasterPass = true;
        bool bRTXPass = false;

        bool operator==(const RenderingMetaData& other) const
        {
            return bRasterPass == other.bRasterPass && bRTXPass == other.bRTXPass;
        }
    };

    struct RenderContext
    {
        RenderingMetaData metaData;
        // Pipeline
        std::vector<DrawCallData> DrawCalls;
    };

    struct RenderingStatistics
    {
        int DrawCallCunt = 0;
    };
}

#endif //VULKANSTRUCTS_HPP
