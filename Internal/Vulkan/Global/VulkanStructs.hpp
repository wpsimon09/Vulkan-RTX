//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Vulkan/Global/GlobalVulkanEnums.hpp"
#include "VMA/vk_mem_alloc.h"
#include "glm/glm.hpp"
#include "Application/Rendering/Material/PBRMaterial.hpp"
#include "Vulkan/Utils/VUniformBufferManager/UnifromsRegistry.hpp"
#include "Application/Structs/ParameterStructs.hpp"

#include <map>


namespace VulkanCore {
class VImage2;
}
namespace VulkanUtils {
class VRasterEffect;
}

namespace ApplicationCore {
class BaseMaterial;
class EffectsLibrary;
}  // namespace ApplicationCore

namespace LightStructs {
struct SceneLightInfo;
}

namespace VulkanStructs {
template <typename T = uint32_t>
struct VImageData
{
    T*           pixels;
    int          widht, height, channels;
    std::string  fileName   = "generated by Vulkan";
    EImageSource sourceType = EImageSource::Generated;
    vk::Format   format     = vk::Format::eR8G8B8A8Unorm;

    std::optional<size_t> offset = 0;


    size_t GetSize() const
    {
        if(std::is_same<T, uint32_t>::value)
            return widht * height * sizeof(T);
        else if(std::is_same<T, float>::value)
            return widht * height * channels * sizeof(float);
        else
            throw std::invalid_argument("Wrong image format supplied, supported formats are float and uint32_t");
    }
    void Clear() const
    {
        if(pixels && EImageSource::File)
        {
            stbi_image_free(pixels);
        }
    }
};


struct VBounds
{
    glm::vec3                origin;
    glm::vec3                extents;
    glm::vec3                max     = {-1.5f, -1.5f, -1.5f};  // min point in world space
    glm::vec3                min     = {1.5f, 1.5f, 1.5f};     // max point in world space
    std::array<glm::vec3, 8> corners = {
        glm::vec3{1, 1, 1},  glm::vec3{1, 1, -1},  glm::vec3{1, -1, 1},  glm::vec3{1, -1, -1},
        glm::vec3{-1, 1, 1}, glm::vec3{-1, 1, -1}, glm::vec3{-1, -1, 1}, glm::vec3{-1, -1, -1},

    };

    void ProjectToWorld(const glm::mat4& modelMatrix)
    {
        for(auto corner : corners)
        {
            corner = modelMatrix * glm::vec4(origin + (corner * extents), 1.0f);

            min = glm::min(min, corner);
            max = glm::max(max, corner);
        }
    }

    float radius;
};


struct VRenderingStatistics
{
    int DrawCallCount = 0;
};

// holds offset to the larger buffer that is in GPU to prevent fragmentation
struct VGPUSubBufferInfo
{
    vk::DeviceSize size = 0;
    vk::DeviceSize offset = 0;

    vk::Buffer        buffer = nullptr;
    int               index = -1;
    int               BufferID = -1;
    vk::DeviceAddress bufferAddress;


    bool operator==(const VGPUSubBufferInfo& other) const { return BufferID == other.BufferID; }

    bool operator!=(const VGPUSubBufferInfo& other) const { return BufferID != other.BufferID; }
};
;

struct VMeshData
{
    VGPUSubBufferInfo vertexData;
    VGPUSubBufferInfo indexData;
    VGPUSubBufferInfo vertexData_BB;
    VGPUSubBufferInfo indexData_BB;
    VBounds           bounds;
};

struct VMeshData2 {
    VGPUSubBufferInfo* vertexData;
    VGPUSubBufferInfo* indexData;
    VBounds            bounds;
};

struct VGPUBufferInfo
{
    vk::DeviceSize size          = 0;
    vk::DeviceSize currentOffset = 0;
};

template <typename T>
struct VReadBackBufferInfo
{
    std::vector<T> data;
    int            bufferID;
    size_t         size;
};

struct VStagingBufferInfo
{
    void*          mappedPointer;
    vk::DeviceSize size;
    vk::DeviceSize dstOffset;
    VmaAllocation  m_stagingAllocation;
    VkBuffer       m_stagingBufferVMA;
    vk::Buffer     m_stagingBufferVK;

    VkBuffer copyDstBuffer;
};

struct VDrawCallData
{
    uint32_t indexCount    = 0;
    uint32_t firstIndex    = 0;
    uint32_t indexCount_BB = 36;
    uint32_t instanceCount = 1;

    VGPUSubBufferInfo* vertexData = nullptr;
    VGPUSubBufferInfo* indexData  = nullptr;
    VBounds*           bounds     = nullptr;

    mutable int drawCallID = 0;

    glm::mat4 modelMatrix{};
    glm::vec3 position{};

    float depth = -1.0f;

    unsigned long key = 0;

    bool inDepthPrePass       = true;
    bool selected             = false;
    bool postProcessingEffect = false;

    ApplicationCore::BaseMaterial* material;
    uint32_t                       effect;
    int                            materialIndex = 0;
};

/**
 * Struct that represent single descriptor sets it holds:
 *  - its layout
 *  - separate sets per frame in flight
 *  - writes per set, each write is accessed by the "current frame" variable and binding
 *  example writes[currentFrame = 0 ][binding = 1] retrieves write for binding 1 and frame 0 
 */
struct VDescriptorSet
{
    std::vector<vk::DescriptorSet> sets;                               // per frame in flight
    vk::DescriptorSetLayout        layout;                             // set layout
    std::map<uint32_t, std::map<int, vk::WriteDescriptorSet>> writes;  // writes are per frame in flight, map key is the frame and
    // value is the vector of writes, second map is for binding/write relations
};


struct PostProcessingContext
{
    VulkanCore::VImage2*                 sceneRender;
    VulkanCore::VImage2*                 shadowMap;
    LensFlareParameters*                 lensFlareParameters;
    ToneMappingParameters*               toneMappingParameters;
    LuminanceHistogramParameters*        luminanceHistrogramParameters;
    LuminanceHistogramAverageParameters* luminanceAverageParameters;

    float deltaTime       = 0.0;
    bool  lensFlareEffect = false;
};

struct BufferHandle
{
    VmaAllocation     allocation{};
    VkBuffer          buffer{};
    vk::DeviceAddress bufferAddress{};
    vk::DeviceSize    size{0};
    void*             mappedPtr;
};


}  // namespace VulkanStructs

#endif  //VULKANSTRUCTS_HPP
