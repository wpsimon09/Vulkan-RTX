//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Application/Rendering/Material/Material.hpp"
#include "VMA/vk_mem_alloc.h"

#ifndef BUFFER_SIZE
    #define BUFFER_SIZE 16777216 // 16MB
#endif


namespace LightStructs
{
    struct SceneLightInfo;
}

namespace VulkanStructs
{
    template<typename T = uint32_t>
    struct ImageData
    {
        T* pixels;
        int widht, height, channels;
        std::string fileName = "generated by Vulkan";

        size_t GetSize() const {
            if (std::is_same<T, uint32_t>::value)
                return widht * height  * sizeof(T);
            else if (std::is_same<T, float>::value)
                return widht * height * channels * sizeof(float);
            else
                throw std::invalid_argument("Wrong image format supplied, supported formats are float and uint32_t");
        }
        void Clear() const {
            stbi_image_free(pixels);
        }
    };


    struct Bounds
    {
        glm::vec3 origin;
        glm::vec3 extents;
        glm::vec3 max = {-1.5f, -1.5f, -1.5f}; // min point in world space
        glm::vec3 min = {1.5f, 1.5f, 1.5f}; // max point in world space
        std::array<glm::vec3, 8> corners = {
            glm::vec3 { 1, 1, 1 },
            glm::vec3 { 1, 1, -1 },
            glm::vec3 { 1, -1, 1 },
            glm::vec3 { 1, -1, -1 },
            glm::vec3 { -1, 1, 1 },
            glm::vec3 { -1, 1, -1 },
            glm::vec3 { -1, -1, 1 },
            glm::vec3 { -1, -1, -1 },

        };

        void ProjectToWorld(const glm::mat4& modelMatrix)
        {
            for (auto corner : corners)
            {
                corner = modelMatrix * glm::vec4(origin + (corner * extents), 1.0f);

                min = glm::min(min, corner);
                max = glm::max(max, corner);
            }
        }

        float radius;
    };



    struct RenderingMetaData
    {
        bool bOpaquePass = true;
        bool bRTXPass = false;
        bool bEditorBillboardPass = false;
        bool bDebugGeometryPass = false;
        bool bTransparentPass = false;
        
    
        bool operator==(const RenderingMetaData& other) const
        {
            return bOpaquePass == other.bOpaquePass && bRTXPass == other.bRTXPass && bEditorBillboardPass == other.bEditorBillboardPass;
        }

        bool IsRenderingContextMainLightPassOnly() const {return bOpaquePass && !bRTXPass && !bEditorBillboardPass;}
        bool IsRenderingContextRTXOnly() const {return !bOpaquePass && bRTXPass && !bEditorBillboardPass;}
        bool IsRenderingContextBilboardOnly() const {return !bOpaquePass && !bRTXPass && bEditorBillboardPass;}
    };

    struct RenderingStatistics
    {
        int DrawCallCount = 0;
    };

    // holds offset to the larger buffer that is in GPU to prevent fragmentation
    struct GPUSubBufferInfo
    {
        vk::DeviceSize size;
        vk::DeviceSize offset;

        vk::Buffer buffer;
        int ID;

        bool operator==(const GPUSubBufferInfo& other) const
        {
            return ID == other.ID;
        }

        bool operator!=(const GPUSubBufferInfo& other) const
        {
            return ID != other.ID;
        }

    };;

    struct MeshData
    {
        GPUSubBufferInfo vertexData;
        GPUSubBufferInfo indexData;
        GPUSubBufferInfo vertexData_BB;
        GPUSubBufferInfo indexData_BB;
        Bounds bounds;
    };

    struct GPUBufferInfo
    {
        vk::DeviceSize size = BUFFER_SIZE;
        vk::DeviceSize currentOffset = 0;
        vk::DeviceSize copyOffSet = 0;

        vk::Buffer bufferVK;
        vk::BufferUsageFlags usageFlags;
        VkBuffer bufferVMA;
        VmaAllocation allocationVMA;

        int ID;

        vk::DeviceSize GetAvailableSize() const { return (currentOffset >= size) ? 0 : (size - currentOffset); }
        bool WillNewBufferFit(vk::DeviceSize size) const { return size <= GetAvailableSize(); }
    };

    struct StagingBufferInfo
    {
        void *mappedPointer;
        vk::DeviceSize size;
        vk::DeviceSize dstOffset;
        VmaAllocation m_stagingAllocation;
        VkBuffer m_stagingBufferVMA;
        vk::Buffer m_stagingBufferVK;

        VkBuffer copyDstBuffer;
    };

struct DrawCallData
{
    uint32_t indexCount = 0;
    uint32_t firstIndex = 0;
    uint32_t indexCount_BB = 36;
    uint32_t instanceCount = 1;
    mutable int drawCallID = 0;

    Bounds* bounds = nullptr;
    MeshData* meshData = nullptr;

    glm::mat4 modelMatrix;
    glm::vec3 position;

    float depth = -1.0f;
    bool renderOutline = false;
    bool isEditorBilboard = false;

    std::shared_ptr<ApplicationCore::Material> material;
};

struct RenderContext
{
    // all draw calls that can be inside the egine
    // TODO: maybe add unordered map instead of vector according ot this
    // @link: https://realtimecollisiondetection.net/blog/?p=86

    glm::mat4 view{};
    glm::mat4 projection{};

    std::pair<RenderingMetaData, std::vector<DrawCallData>> MainLightPassOpaque;
    std::pair<RenderingMetaData, std::vector<DrawCallData>> MainLightPassTransparent;

    std::pair<RenderingMetaData, std::vector<DrawCallData>> EditorBillboardPass;
    std::pair<RenderingMetaData, std::vector<DrawCallData>> SelectedGeometryPass;
    std::pair<RenderingMetaData, std::vector<DrawCallData>> RayTracingPlanePass;
    std::pair<RenderingMetaData, std::vector<DrawCallData>> DebugGeometryPass;


    void ExtractDepthValues(glm::vec3& cameraPosition)
    {
        for (auto &drawCall: MainLightPassOpaque.second)
            drawCall.depth = glm::length(cameraPosition - drawCall.position);
    }

    static bool CompareByDeptDesc(const DrawCallData& DrawCallA, const DrawCallData& DrawCallB)
    {
        return DrawCallA.depth > DrawCallB.depth;
    }

    static bool CompareByDeptAsc(const DrawCallData& DrawCallA, const DrawCallData& DrawCallB)
    {
        return DrawCallA.depth< DrawCallB.depth;
    }

    RenderContext(): MainLightPassOpaque(), EditorBillboardPass(), SelectedGeometryPass(), RayTracingPlanePass()
    {
        MainLightPassOpaque.first.bEditorBillboardPass = false;
        MainLightPassOpaque.first.bOpaquePass = true;
        MainLightPassOpaque.first.bRTXPass= false;
        MainLightPassOpaque.first.bDebugGeometryPass = false;
        MainLightPassOpaque.first.bTransparentPass = false;

        EditorBillboardPass.first.bEditorBillboardPass = true;
        EditorBillboardPass.first.bRTXPass = false;
        EditorBillboardPass.first.bOpaquePass = false;
        EditorBillboardPass.first.bDebugGeometryPass = false;
        EditorBillboardPass.first.bTransparentPass = false;

        RayTracingPlanePass.first.bRTXPass= true;
        RayTracingPlanePass.first.bEditorBillboardPass = false;
        RayTracingPlanePass.first.bOpaquePass = false;
        RayTracingPlanePass.first.bDebugGeometryPass = false;
        RayTracingPlanePass.first.bTransparentPass = false;

        DebugGeometryPass.first.bDebugGeometryPass = true;
        DebugGeometryPass.first.bEditorBillboardPass = true;
        DebugGeometryPass.first.bOpaquePass = false;
        DebugGeometryPass.first.bRTXPass = false;
        DebugGeometryPass.first.bTransparentPass = false;

        MainLightPassTransparent.first.bOpaquePass = false;
        MainLightPassTransparent.first.bTransparentPass = true;
        MainLightPassTransparent.first.bRTXPass = false;
        MainLightPassTransparent.first.bEditorBillboardPass = false;    
        MainLightPassTransparent.first.bDebugGeometryPass = false;
    }

    void GetAllDrawCall(std::vector<DrawCallData>& outDrawCalls)
    {
        outDrawCalls.clear();
        outDrawCalls.reserve(
            MainLightPassOpaque.second.size() +
            EditorBillboardPass.second.size() +
            DebugGeometryPass.second.size() + 
            MainLightPassTransparent.second.size()
        );

        outDrawCalls.insert(outDrawCalls.end(), MainLightPassOpaque.second.begin(), MainLightPassOpaque.second.end());
        outDrawCalls.insert(outDrawCalls.end(), MainLightPassTransparent.second.begin(), MainLightPassTransparent.second.end());
        outDrawCalls.insert(outDrawCalls.end(), EditorBillboardPass.second.begin(), EditorBillboardPass.second.end());
        outDrawCalls.insert(outDrawCalls.end(), DebugGeometryPass.second.begin(), DebugGeometryPass.second.end());

    }

    std::vector<DrawCallData*> GetAllDrawCall()
    {
        std::vector<DrawCallData*> allDrawCalls;
        allDrawCalls.reserve(
            MainLightPassOpaque.second.size() +
            EditorBillboardPass.second.size() +
            SelectedGeometryPass.second.size() +
            RayTracingPlanePass.second.size() + 
            DebugGeometryPass.second.size() +
            MainLightPassTransparent.second.size()
        );

        // Store pointers to original DrawCallData instances
        for (auto& drawCall : MainLightPassOpaque.second)
            allDrawCalls.push_back(&drawCall);
        for (auto& drawCall : EditorBillboardPass.second)
            allDrawCalls.push_back(&drawCall);
        for (auto& drawCall : SelectedGeometryPass.second)
            allDrawCalls.push_back(&drawCall);
        for (auto& drawCall : RayTracingPlanePass.second)
            allDrawCalls.push_back(&drawCall);
        for (auto& drawCall : DebugGeometryPass.second)
            allDrawCalls.push_back(&drawCall);
        for (auto& drawCall : MainLightPassTransparent.second)
            allDrawCalls.push_back(&drawCall);

        return allDrawCalls;
    }

    void AddDrawCall(const RenderingMetaData& drawCallMetaDat,DrawCallData& DrawCall)
    {
        if (drawCallMetaDat == MainLightPassOpaque.first) MainLightPassOpaque.second.emplace_back(DrawCall);
        if (drawCallMetaDat == MainLightPassTransparent.first) MainLightPassOpaque.second.emplace_back(DrawCall);

        if (drawCallMetaDat == RayTracingPlanePass.first) RayTracingPlanePass.second.emplace_back(DrawCall);
        if (drawCallMetaDat == EditorBillboardPass.first) EditorBillboardPass.second.emplace_back(DrawCall);
        //if (drawCallMetaDat == SelectedGeometryPass.first) SelectedGeometryPass.second.emplace_back(DrawCall);
        if (drawCallMetaDat == DebugGeometryPass.first) DebugGeometryPass.second.emplace_back(DrawCall);

    }

    void ResetAllDrawCalls()
    {
        MainLightPassOpaque.second.clear();
        EditorBillboardPass.second.clear();
        SelectedGeometryPass.second.clear();
        RayTracingPlanePass.second.clear();
        DebugGeometryPass.second.clear();
    }
};

}

#endif //VULKANSTRUCTS_HPP
