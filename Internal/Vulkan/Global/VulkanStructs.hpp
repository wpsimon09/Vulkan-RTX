//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Application/Rendering/Material/Material.hpp"
#include "glm/glm.hpp"
#include "VMA/vk_mem_alloc.h"

#ifndef BUFFER_SIZE
    #define BUFFER_SIZE 16777216 // 16MB
#endif


namespace VulkanStructs
{
    struct ImageData
    {
        uint32_t* pixels;
        int widht, height, channels;
        std::string fileName = "generated by Vulkan";

        size_t GetSize() const {
            return widht * height * channels;
        }
        void Clear() const {
            stbi_image_free(pixels);
        }
    };

    struct Bounds
    {
        glm::vec3 origin;
        glm::vec3 extents;
        glm::vec3 max = {-1.5f, -1.5f, -1.5f}; // min point in world space
        glm::vec3 min = {1.5f, 1.5f, 1.5f}; // max point in world space
        std::array<glm::vec3, 8> corners = {
            glm::vec3 { 1, 1, 1 },
            glm::vec3 { 1, 1, -1 },
            glm::vec3 { 1, -1, 1 },
            glm::vec3 { 1, -1, -1 },
            glm::vec3 { -1, 1, 1 },
            glm::vec3 { -1, 1, -1 },
            glm::vec3 { -1, -1, 1 },
            glm::vec3 { -1, -1, -1 },

        };

        void ProjectToWorld(const glm::mat4& modelMatrix)
        {
            for (auto corner : corners)
            {
                corner = modelMatrix * glm::vec4(origin + (corner * extents), 1.0f);

                min = glm::min(min, corner);
                max = glm::max(max, corner);
            }
        }

        float radius;
    };



    struct RenderingMetaData
    {
        bool bRasterPass = true;
        bool bRTXPass = false;
        float minZ = 10000;
        glm::mat4 view;
        glm::mat4 projection;

        bool operator==(const RenderingMetaData& other) const
        {
            return bRasterPass == other.bRasterPass && bRTXPass == other.bRTXPass;
        }
    };

    struct RenderingStatistics
    {
        int DrawCallCount = 0;
    };

    // holds offset to the larger buffer that is in GPU to prevent fragmentation
    struct GPUSubBufferInfo
    {
        vk::DeviceSize size;
        vk::DeviceSize offset;

        vk::Buffer buffer;
    };

    struct MeshData
    {
        GPUSubBufferInfo vertexData;
        GPUSubBufferInfo indexData;
        GPUSubBufferInfo vertexData_BB;
        GPUSubBufferInfo indexData_BB;
        Bounds bounds;
    };

    struct GPUBufferInfo
    {
        vk::DeviceSize size = BUFFER_SIZE;
        vk::DeviceSize currentOffset = 0;
        vk::DeviceSize copyOffSet = 0;

        vk::Buffer bufferVK;
        vk::BufferUsageFlags usageFlags;
        VkBuffer bufferVMA;
        VmaAllocation allocationVMA;

        int ID;

        vk::DeviceSize GetAvailableSize() const { return (currentOffset >= size) ? 0 : (size - currentOffset); }
        bool WillNewBufferFit(vk::DeviceSize size) const { return size <= GetAvailableSize(); }
    };

    struct StagingBufferInfo
    {
        void *mappedPointer;
        vk::DeviceSize size;
        vk::DeviceSize dstOffset;
        VmaAllocation m_stagingAllocation;
        VkBuffer m_stagingBufferVMA;
        vk::Buffer m_stagingBufferVK;

        VkBuffer copyDstBuffer;
    };

struct DrawCallData
{
    uint32_t indexCount = 0;
    uint32_t firstIndex = 0;
    uint32_t indexCount_BB = 36;
    uint32_t instanceCount = 1;
    mutable int drawCallID = 0;

    Bounds* bounds = nullptr;
    MeshData* meshData = nullptr;

    glm::mat4 modelMatrix;
    glm::vec3 position;

    float depth = -1.0f;
    bool renderOutline = false;

    std::shared_ptr<ApplicationCore::Material> material;

    // Default constructor
    DrawCallData() = default;

    // Copy constructor
    DrawCallData(const DrawCallData& other)
        : indexCount(other.indexCount),
          firstIndex(other.firstIndex),
          indexCount_BB(other.indexCount_BB),
          instanceCount(other.instanceCount),
          drawCallID(other.drawCallID),
          bounds(other.bounds),
          meshData(other.meshData),
          modelMatrix(other.modelMatrix),
          depth(other.depth),
          renderOutline(other.renderOutline),
          material(other.material),
          position(other.position){}

    // Copy assignment operator
    DrawCallData& operator=(const DrawCallData& other)
    {
        if (this != &other)
        {
            indexCount = other.indexCount;
            firstIndex = other.firstIndex;
            indexCount_BB = other.indexCount_BB;
            instanceCount = other.instanceCount;
            drawCallID = other.drawCallID;
            bounds = other.bounds;
            meshData = other.meshData;
            modelMatrix = other.modelMatrix;
            depth = other.depth;
            renderOutline = other.renderOutline;
            material = other.material;
            position = other.position;
        }
        return *this;
    }

    // Move constructor
    DrawCallData(DrawCallData&& other) noexcept
        : indexCount(other.indexCount),
          firstIndex(other.firstIndex),
          indexCount_BB(other.indexCount_BB),
          instanceCount(other.instanceCount),
          drawCallID(other.drawCallID),
          bounds(other.bounds),
          meshData(other.meshData),
          modelMatrix(std::move(other.modelMatrix)),
          depth(other.depth),
          renderOutline(other.renderOutline),
          material(std::move(other.material))
    {
        other.bounds = nullptr;
        other.meshData = nullptr;
    }

    // Move assignment operator
    DrawCallData& operator=(DrawCallData&& other) noexcept
    {
        if (this != &other)
        {
            indexCount = other.indexCount;
            firstIndex = other.firstIndex;
            indexCount_BB = other.indexCount_BB;
            instanceCount = other.instanceCount;
            drawCallID = other.drawCallID;
            bounds = other.bounds;
            meshData = other.meshData;
            modelMatrix = std::move(other.modelMatrix);
            depth = other.depth;
            renderOutline = other.renderOutline;
            material = std::move(other.material);
            position = other.position;

            other.bounds = nullptr;
            other.meshData = nullptr;
        }
        return *this;
    }
};

    struct RenderContext
    {
        RenderingMetaData metaData;
        // Pipeline
        std::vector<DrawCallData> DrawCalls;

        void ExtractDepthValues(glm::vec3& cameraPosition)
        {
            for (auto &drawCall: DrawCalls)
                drawCall.depth = glm::length(cameraPosition - drawCall.position);
        }

        static bool CompareByDeptDesc(const DrawCallData& DrawCallA, const DrawCallData& DrawCallB)
        {
            return DrawCallA.depth > DrawCallB.depth;
        }

        static bool CompareByDeptAsc(const DrawCallData& DrawCallA, const DrawCallData& DrawCallB)
        {
            return DrawCallA.depth< DrawCallB.depth;
        }


    };

}

#endif //VULKANSTRUCTS_HPP
