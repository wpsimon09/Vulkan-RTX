//
// Created by wpsimon09 on 20/11/24.
//

#ifndef VULKANSTRUCTS_HPP
#define VULKANSTRUCTS_HPP

#include <stb_image/stb_image.h>
#include <vulkan/vulkan.hpp>

#include "Application/Rendering/Material/Material.hpp"
#include "glm/glm.hpp"
#include "VMA/vk_mem_alloc.h"

#ifndef BUFFER_SIZE
    #define BUFFER_SIZE 16777216 // 16MB
#endif


namespace VulkanStructs
{
    struct ImageData
    {
        uint32_t* pixels;
        int widht, height, channels;
        std::string fileName = "generated by Vulkan";

        size_t GetSize() const {
            return widht * height * channels;
        }
        void Clear() const {
            stbi_image_free(pixels);
        }
    };

    struct Bounds
    {
        glm::vec3 origin;
        glm::vec3 extents;
        float radius;
    };

    struct RenderingMetaData
    {
        bool bRasterPass = true;
        bool bRTXPass = false;

        bool operator==(const RenderingMetaData& other) const
        {
            return bRasterPass == other.bRasterPass && bRTXPass == other.bRTXPass;
        }
    };

    struct RenderingStatistics
    {
        int DrawCallCunt = 0;
    };

    // holds offset to the larger buffer that is in GPU to prevent fragmentation
    struct GPUSubBufferInfo
    {
        vk::DeviceSize size;
        vk::DeviceSize offset;

        vk::Buffer buffer;
    };

    struct MeshData
    {
        GPUSubBufferInfo vertexData;
        GPUSubBufferInfo indexData;
        GPUSubBufferInfo vertexData_BB;
        GPUSubBufferInfo indexData_BB;
        Bounds bounds;
    };

    struct GPUBufferInfo
    {
        vk::DeviceSize size = BUFFER_SIZE;
        vk::DeviceSize currentOffset = 0;
        vk::DeviceSize copyOffSet = 0;

        vk::Buffer bufferVK;
        vk::BufferUsageFlags usageFlags;
        VkBuffer bufferVMA;
        VmaAllocation allocationVMA;

        int ID;

        vk::DeviceSize GetAvailableSize() {return size - currentOffset;};
    };

    struct StagingBufferInfo
    {
        void *mappedPointer;
        vk::DeviceSize size;
        vk::DeviceSize dstOffset;
        VmaAllocation m_stagingAllocation;
        VkBuffer m_stagingBufferVMA;
        vk::Buffer m_stagingBufferVK;

        VkBuffer copyDstBuffer;
    };

    struct DrawCallData
    {
        uint32_t indexCount = 0;
        uint32_t firstIndex =0;
        uint32_t AABBIndexCount = 0;
        uint32_t instanceCount = 1;
        mutable int objectID = 0; // optional if i need to access other stuff in the array of objects

        Bounds *bounds;
        MeshData* meshData;

        glm::mat4& modelMatrix;

        bool renderOutline = false;

        // material descriptor
        std::shared_ptr<ApplicationCore::Material> material;

    };

    struct RenderContext
    {
        RenderingMetaData metaData;
        // Pipeline
        std::vector<DrawCallData> DrawCalls;
    };

}

#endif //VULKANSTRUCTS_HPP
